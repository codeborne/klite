# A Project You Actually Want to Code In: What DX Should Look Like on the JVM

DevClub Estonia talk

## Abstract

What if we ditched Spring, annotations, and all the magic — and built a JVM backend that's simple, transparent, and a joy to work with? In this talk, I’ll share what good Developer Experience means to me: expressive, type-safe, and predictable code. No magical DI frameworks, clear architecture, smooth database access, and shared types for the frontend. Kotlin helps — but the key is an intentional approach to project design.



## The Rails doctrine: Optimize for programmer happiness

https://rubyonrails.org/doctrine

Ruby: too dynamic
My favorite stack: Svelte + Kotlin + Klite + PostgreSQL


## Principles of good DX:

- Avoid mistakes as much as possible
- Good Signal to Noise Ratio (SNR) = little boilerplate
- Expressive code, showing **intent**



## AI & Vibe coding

- More productivity boost from simplicity
- AI after it is simple enough (also will be cheaper)



## State of the game

- On the JVM (also .NET), there is a common tendency to overcomplicate things
- That got worse when frontend/backend split became mainstream
- Koltin emerged as a new language people “love”



## Kotlin & Klite

https://github.com/codeborne/klite

- The experiment of preferring simplicity and DX
- All code is explicit and debuggable
- 12-factor apps by default
- Zero dependencies, to avoid unpredictable vulnerabilities
  - Including JDK built-in non-blocking HTTP server


## Make it easy to contribute

- Frontend, backend, DB in the same repo
- App runs out of the box (run configurations provided)
- Dev .env file (config) in Git for easy onboarding
- Keep also .editorconfig / .idea folder in Git
- Tests run out of the box, and are fast
- Auto-start DB for app and tests using Docker Compose



## Simple code structure
- just src/test, not `src/main/java`
- no deeply nested package names (start with single level)
- db migrations aren't hidden in `src/main/resources`



## Ultimate type safety

Proper classes for values (Phone, Email, PersonalCode, URL), with validation
- They should work with JSON, request parameters, and database
- Enums also


Explicit nullability
- optional values checked at compile-time
- works as documentation
- auto-validation when deserializing
- JSON parser deserializes empty strings to nulls


TypeSafe `Id<T>` that you cannot mixup

Ids autogenerated on either frontend or backend
- UUID vs TSID




## Kotlin specifics

- operator overloading for monetary (or other numeric) types
  `(loan.amount + loan.residualValue) / 3.d`   -vs-
  `new BigDecimal(100.7).add(new BigDecimal(25)).divide(new BigDecimal(3))`

- extension functions and properties
  - for improving built-in JVM types
  - also to get `10.minutes` or `5.days` or `100.d` in code


- default arguments for functions with optional behaviour
  `EnrollmentRepository.aggregated(userId = user.id)`
  `EnrollmentRepository.aggregated(courseId = course.id)`


- spaces in unit test names




## Simple singleton-based Dependency Injection
- constructor-based
- impossible to create invalid instances



## Immutable TestData
- Tests must show the intent without too much boilerplate (or unnecessary initialization)
- BaseMocks to avoid mocking common repos with TestData again and again



## TypeScript types generation for frontend
- including TestData
- enables refactoring and good code completion

https://github.com/codeborne/klite/tree/main/json
https://github.com/codeborne/jvm2dts


## Type-safe translations in UI
- no libraries needed :-)



## Easy way to do DB queries without magical ORM

- using TypeSafe reflection (KProperty)
- `db.select<User>("users", User::name to "John")`
- `db.update("users", User::name to "Anton")`
- `db.query("select something very special with joins")`
- CrudRepository for simple operations
- Automatic logging of all DB updates to `change_history` table
- Optimistic locking is a good idea for most entities
- PG Advisory locks for Jobs



## DB migrations as code, not unmaintainable files
- migration and app users with different grants
- name DB fields the same as class properties (no need for mapping)



## Repository tests
- Using same migration scripts
- Real DB ran by Docker Compose (not Test Containers)
- Separate main & test & e2e DBs in the same DB instance



# Good traceable request logging
- with parameters, response codes and times
- all other logs with requestId
- threadId instead of MDC
